# Redis

## 快，为什么快

- 基于内存实现，完全内存计算
- 单线程操作，避免了线程上下文切换操作
- **多路I/O复用的线程模型**，实现了一个线程监控多个IO流，及时响应请求
- redis对外部的依赖比较少，属于轻量级内存数据库

目前支持I/O多路复用的系统调用有**select，pselect，poll，epoll**等函数。I/O多路复用就是通过一种机制**一个进程可以监视多个描述符**，一旦某个描述符读就绪或者写就绪，其能够通知应用程序进行相应的读写操作。

## 常用数据类型与命令

- **string：**redis 中字符串 value 最大可为512M。可以用来做一些计数功能的缓存（也是实际工作中最常见的）。
- **list：**简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部（左边）或者尾部（右边），其底层实现是一个链表。可以实现一个简单消息队列功能，做基于redis的分页功能等。
- **set：**是一个字符串类型的无序集合。可以用来进行全局去重等。
- **sorted set：**是一个字符串类型的有序集合，给每一个元素一个固定的**分数score**来保持顺序。可以用来做排行榜应用或者进行范围查找等。
- **hash：**键值对集合，是一个字符串类型的 Key和 Value 的映射表，也就是说其存储的Value是一个键值对（Key- Value）。可以用来存放一些具有特定结构的信息。
- **HyperLogLog** 只用12k 实现独立计数，可以查 UV(存IP)
- **BitMap** 按位存储 适合存储大量连续的布尔值DAU（存用户ID）

### 高级命令

1. **游标查询：**`scan 0 match like* count 6 `
2. **分布式锁**： `setnx locknx task`   释放锁：`expire locknx 2`  原子性操作![image-20210530110800271](E:\nutstore\md\Redis.assets\image-20210530110800271.png)

3. **异步队列** ：一个消费者 `rpush testlist 300 ----> blpop testlist 30`   消费者组 

![image-20210530111851470](E:\nutstore\md\Redis.assets\image-20210530111851470.png)

## 持久化方式

### RDB（快照存储）

1. 设置 redis.config（配置 ），

- **NETWORK：**该模块可以配置一些redis服务器地址，端口以及超时时间等
- **GENERAL：**该模块可以对日志文件的路径和日志级别等进行配置
- **SNAPSHOTTING：**redis持久化配置信息等
- **REPLICATION：**redis集群配置等信息
- **MEMORY MANAGEMENT：**内存管理，包括数据过期删除策略信息的设置
- **APPEND ONLY MODE：**日志持久化方式信息设置

2. save， bgsave(不阻塞父进程)

3. 缺点

- 内存数据的全量同步，数据量大会由于/O而严重影响性能
- 可能会因为 Redist挂掉而丢失从当前至最近一次快照期间的数据

### AOF（增量存储）

 **AOF日志重写：**

- AOF文件会随着服务器运行的时间越来越大，可以通过AOF重写来控制AOF文件的大小。
- AOF重写会首先读取数据库中现有的键值对状态，然后根据类型使用一条命令来替代前面对键值对操作的多条命令。
- 使用命令 bgrewriteaof 来实现AOF重写

**AOF重写缓存区：**
redis 是单线程工作，当AOF文件较大时重写时间会比较长，在重写 AOF 期间，redis将长时间无法处理客户端请求。为了解决这个问题，可以将 AOF 重写程序放到子进程中执行，好处如下：

- 子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理其它客户端请求。
- 子进程带有父进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。

**子进程中AOF重写导致的问题：**

- 子进程在进行 AOF 重写期间，服务器进程依然可以处理其它客户端请求，这就会导致数据库状态已经发生了改变，使得当前数据库数据状态和重写后的 AOF 文件中的数据不一致。
- 也就是出现了AOF文件和数据库中数据不一致的问题。

**数据状态不一致解决办法：**

- redis 服务器设置了一个 AOF 重写缓冲区。这个缓冲区在创建子进程后开始使用，当redis服务器执行一个客户端的写请求命令，之后将这个写命令也发送到 AOF 重写缓冲区。
- 当子进程完成 AOF 日志重写之后，给父进程发送信号，父进程接收此信号后，将 AOF 重写缓冲区的内容写到新的 AOF 文件中，保持数据的一致性。

### 数据恢复

1. **重启先aof 再 rdb**

![image-20210530113917863](E:\nutstore\md\Redis.assets\image-20210530113917863.png)

2 **混合持久化**

BGSAVET做镜像全量持久化，AOF做增量持久化

## 使用redis可能出现的问题

### 缓存雪崩：

**举例：**缓存同一时间大面积的失效，这个时候又来的一波请求都到数据库上，导致数据库连接异常。

**解决办法：**可以给缓存设置不同的缓存时间，更新数据使用互斥锁或者通过双缓存在避免缓存雪崩。

### 缓存击穿：

**举例：**redis中存储的是热点数据，当高并发请求访问redis中热点数据的时候，如果redis中的数据过期了，会造成缓存击穿的现象，请求都打到了数据库上。

**解决办法：**使用互斥锁，只让一个请求去load DB，成功之后重新写缓存，其余请求没有获取到互斥锁，可以尝试重新获取缓存中的数据。。

### 缓存穿透：

**举例：**故意的去请求缓存中不存在的数据，导致请求都打到了数据库上，导致数据库异常。

**解决办法：**可以使用互斥锁或者无论是否取到结果都将结果存入缓存，还可以使用有效的机制（比如布隆过滤器）来拦截不合法的key值等。

### 数据库和缓存的双写一致性问题：

在高并发请求下很容易导致数据不一致的问题，如果你的业务需要保证数据的强一致性，那么建议不要使用缓存。在数据库中和缓存数据的删除或者写入过程中，如果有失败的情况，会导致数据的不一致。

**解决办法：**

- **双删延时的解决办法。**可以先删除缓存数据，然后再更新数据库数据，最后再隔固定的时间再次删除缓存。
- **更新数据库产生的binlog订阅（使用canal）**。将有变化的key记录下来，并且尝试去不断的去删除缓存（如果上次删除缓存失败）

## redis数据过期回收策略与内存淘汰机制

Redis中的数据过期回收策略使用了定期删除和惰性删除相结合的方式。

- **定期删除：**

redis会每隔一定的时间去抽查一定量的数据判断其是否过期，过期则进行删除。

- **惰性删除：**

在获取一个key的时候，redis会检查这个key是否已经过期，若过期，则会进行删除操作。

**内存淘汰机制：**

在配置文件中，我们可以对内存淘汰机制进行配置。当内存使用达到最大值时，redis可以使用的**清除策略**如下：

- **volatile-lru**：利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )
- **allkeys-lru**：利用LRU算法移除任何key
- **volatile-random**：移除设置过过期时间的随机key
- **allkeys-random**：移除随机key
- **volatile-ttl**：移除即将过期的key(minor TTL)
- **noeviction** ：不移除任何key，只是返回一个写错误 ，默认选项

## 主从同步 哨兵 集群

**redis的事务不支持回滚操作**，redis以 MULTI 开始一个事务，然后将多个命令入队到事务中，最后由 EXEC 命令触发事务

