## 数据库面试

### 1 架构

![image-20201113095701209](C:\Users\37779\AppData\Roaming\Typora\typora-user-images\image-20201113095701209.png)

### 2 索引

**为什么要使用索引?**

> 索引是类似于目录的一种结构,可以建立顺序与内容的映射关系,因此引入索引可以增加大规模数据的查找速度

##### **什么样的信息能成为索引**

> 主键或者具有唯一性信息的字段均可成为索引

##### **索引的数据结构(为什么要使用B+树?)**

> 对于数据量比较小的内容可以用哈希表
>
> 对于字段只有固定的某几个可选项的数据可以同`bitmap`数据结构
>
> 对于大部分内容应该采用**B+树**这种数据结构,因为限制数据库查找速度的瓶颈主要输磁盘读写速度,而B+树的高度很矮,因此可以通过很少的磁盘读写进入到叶子结点从而提取到数据.对比其他数据结构他的优点有三:
>
> 1. 磁盘读写效率更高
> 2. 查询速率稳定
> 3. 更有利于数据库的扫描

##### 扩展:B树与B+树的区别(为什么用B+不用B)?

> B+树是B树的变体,定义与B树基本相同,除了:
>
> 1. 非叶子结点的子树指针与关键字个数相同
> 2. 数据全部保存在叶子结点中
> 3. 所有叶子结点均有一个链接指针指向下一个叶子结点
> 4. 每一个非叶子节点所存储的数据一定小于他的右父亲关键字的数据
>
> **因此:**
>
> - B+树是B树的变种，B+树的非叶子节点只用来保存索引，不存储数据，所有的数据都保存在叶子节点；而B树的非叶子节点也会保存数据。这样就使得B+树的查询效率更加稳定，均为从根节点到叶子节点的路径。
>
> - B+树的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B 树更小，同样空间可以读入更多的节点，所以B+树的磁盘读写代价更低

##### 密集索引和稀疏索引的区别

> 密集索引文件中的每个搜索码值都对应一个索引值,innodb主要是密集索引
> 稀疏索引文件只为索引码的某些值建立索引项,myslam主要是稀疏索引

![image-20210531175649108](E:\nutstore\md\数据库面试.assets\image-20210531175649108.png)

> **覆盖索引**：就是把单列的非主键 索引 修改为多字段的联合索引,  在一棵索引数上 就找到了想要的数据, 不需要去主键索引树上,再检索一遍  这个现象,称之为 索引覆盖.

##### 如何定位并优化慢查询Sql

> 1. 根据慢日志查询定位出慢查询
>
>    ```mysql
>    show variables like"%quer%
>    show status like"%slow_queries%
>    set global slow_query_log= on
>    set global long_query_time= 1
>    ```
>
> 2. 使用`explain`等工具分析`SQL`
>
>    ```mysql
>   explain select name from person_info_large order by name desc;
>    -- type里面有index或者or
>    -- extra里面出现using filesort(无法利用索引,走外部排序) 或者 using temporary(使用临时表order by,group by等语句)
>    ```
>    
> 3. 修改改`SQL`或者尽量让该`SQL`走索引
>
> ```mysql
>alter table user add index indax_name (username);
> explain select count(id )from person_info_large；
> explain select count(id)from person_info_ large force index (primary) -- 主键索引不一定比唯一索引快，因为存的东西多
> ```

##### 联合索引的最左匹配原则的成因

> 1.最左前缀匹配原则，非常重要的原则，`mysql` 会一直向右匹配直到遇到范围査询（>、<between、like）就停止匹配，比如`a=3andb=4andc>5andd=6`如果建立（a,b,c,d）顺序的索引，d是用不到索引的，如果建立（a,b,d,c）的索引则都可以用到，a,b,d的顺序可以任意调整。
> 2.=和in可以乱序，比如`a=1andb=2andc=3`建立（a,b,d）索引可以任意顺序， `mysql` 的查询优化器会帮你优化成索引可以识别的形式

##### 索引是建立得越多越好吗

> 1. 数据量小的表不需要建立索引，建立会增加额外的索引开销
> 2. 数据变更需要维护索引，因此更多的索引意味着更多的维护成本
> 3. 更多的索引意味着也需要更多的空间

### 3 锁

##### `MYISAMV`与 `INNODB`关于锁方面的区別是什么

> - `MYISAM`默认用的是表级锁，不支持行级锁
> - `INNODB`默认用的是行级锁，也支持表级锁（如果一个查询没有走索引，则变成表级锁）

扩展:

1 读锁是不允许其他语句进行写入的锁,所以读锁是共享锁

   上了写锁,其他语句是不可能再进行读或者写操作的,故写锁也叫排它锁

2 二者的其他区别是行级锁,事务,外键

##### 效据库事务的四大特性

> **ACID:**
>
> - 原子性（ Atomic): 要么成功,要么不成功
> - 一致性（ Consistency):数目一致,不允许差错
> - 隔离性（ Isolation):并发执行时各个事务不互相干扰
> - 持久性（ Durability）:改变是永久的,且记录也要写入`redo_log`日志中 

##### 事务隔离级别以及各级别下的并发访问题

> - **更新丟失** `mysql` 所有事务隔离级别在数据库层面上均可避免
> - **脏读** READ- COMMITTED事务隔离级别以上可避免
> - **不可重复读**- REPEATABLE-READ事务隔离级别以上可避免
> - **幻读** `SERIALZABLE`事务隔离级别可避免

##### 当前读与快照读

- 当前读： select 。。。 lock in share mode, select。。。for update
- 当前读： update, delete, Insert
- 快照读：一般查询

##### RC、RR级别下的 `INNODBE`的非阻塞读（快照读）如何实现（db_trx_id）



##### `INNODB`可重复读隔离级别别下如何避免幻读

> `INNODBE` RR 级别主要通过next-key方式来避免幻读,而next-key有 行锁 和 gap-lock 组成,gap-lock用在走唯一索引,一般索引,不走索引的情况,只有wheres条件全部命中，否则不会用Gap锁，只会加记录,其他的都会加gap锁

4 日志